- 什么是redis
	
	简单地说Redis就是一个常驻内存的数据库，支持多种数据结构、
	部署方式，还具有事务、持久化等优秀特性。
	相比MySQL等传统数据库，理论上会有更高的读写速度，在一般的
	架构中，常常用作缓存。

- REDIS的数据类型？

	string（字符串）
	hash（哈希）
	list（列表）
	set（集合）
	zset(sorted set：有序集合)
	bitmap

- 使用REDIS有哪些好处？

	1. 对于那些结构化、多范式规则的数据库系统而言，它更具性能优势。
	2. 支持多种数据类型
	3. 操作都是原子的
	4. 可持久化

- REDIS相比 MEMCACHED有哪些优势？

	1. 支持更多的数据结构
	2. 有持久化
	3. 安装简单
	4. 支持分布式架构
	5. 提供更多特性，如支持lua脚本等

- MEMCACHE与REDIS的区别都有哪些？

	同上

- REDIS是单进程单线程的？

	** https://zhuanlan.zhihu.com/p/356059845 **
	在4.0之前，是单线程
	Redis v4.0（引入多线程处理异步任务）
	Redis v6.0（正式在网络模型中实现 I/O 多线程）
	读取客户端请求命令和回写响应数据的逻辑异步化了，交给 I/O 线程去完成。
	命令的执行还是在主线程上完成

- 一个字符串类型的值能存储最大容量是多少？

	512M

- REDIS的持久化机制是什么？各自的优缺点？

	RDB

	1. RDB文件是紧凑的二进制文件，比较适合做冷备，全量复制的场景。
	2. 相对于AOF持久化机制来说，直接基于RDB数据文件来重启和恢复Redis进程，更加快速；
	3. RDB对Redis对外提供的读写服务，影响非常小，可以让Redis保持高性能，
		因为Redis主进程只需要fork一个子进程，让子进程执行磁盘IO操作来进行RDB持久化即可;
	4. 如果想要在Redis故障时，尽可能少的丢失数据，那么RDB没有AOF好。
	5. RDB每次在fork子进程来执行RDB快照数据文件生成的时候，如果数据文件特别大，
		可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒；
	6. RDB无法实现实时或者秒级持久化

	AOF 
	
	1. RDB无法实现实时或者秒级持久化
	2. AOF日志文件以append-only模式写入，写入性能比较高
	3. AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。
	4. 适合做灾难性的误删除紧急恢复
	5. 对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大，恢复速度慢；
	6. AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒
		fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的；

	RDB 和 AOF 选择

	1. 不要仅仅使用RDB，因为那样会导致你丢失很多数据；

	2. 也不要仅仅使用AOF，因为那样有两个问题：

	通过AOF做热备，没有RDB做冷备，恢复速度更快;
	第二，RDB每次简单粗暴生成数据快照，更加健壮，可以避免AOF这种复杂的备份和恢复机制的bug；

	3. 综合使用AOF和RDB两种持久化机制，用AOF来保证数据不丢失，作为数据恢复的第一选择;

	用RDB来做不同程度的冷备，在AOF文件都丢失或损坏不可用的时候，还可以使用RDB来进行快速的数据恢复；

- REDIS过期键的删除策略？

	1. 惰性删除

		所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查：
		如果输入键已经过期，那么将输入键从数据库中删除
		如果输入键未过期，那么不做任何处理
	
	2. 定期删除

		1. 每当周期性函数执行的时候都会执行
		2. 会在规定时间内，分多次遍历数据库中的各个数据库，
			从expired字典中检查一部分键的过期时间，进行删除操作
		3. RDB、AOF文件中不会包含已经过期的键
		4. 当一个键被删除的时候，会向从服务器发送一条DEL命令，
			如果相应成功了才会删除，从服务器不会擅自进行操作

- REDIS的回收策略（淘汰策略）？

	1. 删除策略

	同上

	2. 溢出策略(逐出算法)，可以配置，建议配置为使用LRU

	当redis使用已经达到了最大内存，比如4GB时，如果这时候再往redis里面添加新的Key，
	那么Redis将选择一个Key删除.

	redis的LRU算法，并不是标准的LRU算法。
	
	标准的LRU算法，需要将全部的缓存数据放到队列中，这样会消耗较多的内存。
	特别是对于redis经常缓存亿万的数据来说，将全部的key或者缓存数据放到队列中，
	这几乎是无法想象的灾难。

	redis中近似的LRU算法与标准的LRU算法的区别在于：
	标准的LRU算法会将全部的数据进行统计；而redis近似的LRU算法则是随机采样，
	随机采样指定个数的缓存数据，然后根据采样结果，确定丢弃的缓存数据。

	请注意，这里的丢弃只是从内存中丢弃，数据不会丢失。类似我们硬盘上有16个G的数据，
	但是只有2G的内存，那么需要计算机不断的将新的数据从硬盘读取，覆盖旧的内存数据。

- 为什么REDIS需要把所有数据放到内存中？

	内存操作比硬盘的操作快很多，这是由物理特性的。
	由计算机的存储架构来看，内存操作也会更快。

- REDIS的同步机制了解么？

	TODO

- PIPELINE有什么好处，为什么要用PIPELINE？

	如果将命令分为多个，去请求Redis，就会有多次的RTT，无法避免。
	
	使用pipline可以将请求合并为一次，在一个RTT时间完成多个请求。

	但是pipline不是原子性的，需要注意

- 是否使用过REDIS集群，集群的原理是什么？

	TODO

- REDIS集群方案什么情况下会导致整个集群不可用

	TODO

- REDIS如何设置密码及验证密码？

	1. 配置文件 requirepass
	2. 通过命令 < config set requirepass xxx >
	3. auth xxx
	
- 说说REDIS哈希槽的概念？

	Redis 集群没有使用一致性 hash,而是引入了哈希槽的概念，Redis 集群 有
	16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置 哪
	个槽，集群的每个节点负责一部分 hash 槽。

- REDIS集群的主从复制模型是怎样的？

	TODO

- REDIS集群会有写操作丢失吗？为什么？

	Redis 并不能保证数据的强一致性，这意味这在实际中集群在特定的条件 下可
	能会丢失写操作。

- REDIS集群之间是如何复制的？

	TODO

- REDIS集群最大节点个数是多少？

	16384 个。
	不推荐超过1000个

- 怎么测试REDIS的连通性

	ping 命令

- 怎么理解REDIS事务？

	事务可以一次执行多个命令，并带有两个重要的保证： 

	事务中的所有命令都被序列化并按顺序执行。Redis执行事务期间，
	不会被其它客户端发送的命令打断，事务中的所有命令都作为一个隔离操作顺序执行。

	Redis事务是原子操作，或者执行所有命令或者都不执行。 
	EXEC 命令触发一个事务中所有命令的执行，所以，
	如果一个客户端断在调用EXEC 命令前丢失连接，那么所有的命令不会被执行，
	相反，如果EXEC 被调用，那么所有命令会被执行。	

- REDIS事务相关的命令有哪几个？

	Redis使用MULTI, EXEC, DISCARD 和 WATCH 命令来实现事务功能

	(
		WATCH 命令可以监控一个或多个键，
		一旦其中有一个键被修改（或删除），之后的事务就不会执行。

		监控一直持续到EXEC命令（事务中的命令是在EXEC之后才执行的，
		所以在MULTI命令后可以修改WATCH监控的键值）
	)

- REDIS KEY的过期时间和永久有效分别怎么设置？

	expire xxx time

	persist xxx

	ttl xxx 查看时间

- REDIS如何做内存优化？

	尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的
	内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比
	如你的 web 系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密
	码设置单独的 key,而是应该把这个用户的所有信息存储到一张散列表里面

- 都有哪些办法可以降低REDIS的内存使用情况呢？

	如果你使用的是 32 位的 Redis 实例，可以好好利用 Hash,list,sorted 
	set,set 等集合类型数据，因为通常情况下很多小的 Key-Value 可以用更紧凑
	的方式存放到一起。

- REDIS的内存用完了会发生什么？

	LRU ，参考上面的答案

- 一个REDIS实例最多能存放多少的KEYS？LIST、SET、SORTED SET他们最多能存放多少元素？

	1. 官方给出，理论值是 2 的 32 次方个
	2. 都是 2 的 32 次方个

- MYSQL里有2000w数据，REDIS中只存20w的数据，如何保证REDIS中的数据都是热点数据？

	TODO 
	感觉是不对的答案： redis有数据过期时间时间，以及数据容量达到阈值时，
	根据置换策略，淘汰指定的数据。 

- 假如REDIS里面有1亿个KEY，其中有10w个KEY是以某个固定的已知的前缀开头的，如果将它们全部找出来？
	
	1. keys 

		没有offset、limit参数，不能限制查询个数
		keys是遍历算法，复杂度O(n)，数据量大的时候会导致redis卡顿

	2. scan

		复杂度O(n)，但是scan是通过游标分步进行，不阻塞
		提供limit，可控制返回结果数
		同keys一样，提供模式匹配
		服务器不需要为游标保存状态，唯一状态是scan返回客户端的游标整数
		** 返回结果可能重复，需要客户端去重
		如果遍历过程中有数据修改，改动后的数据不保证同步
		单次返回结果是空的，不表示遍历结束，而要看返回的游标值是否为0

- 如果有大量的KEY需要设置同一时间过期，一般需要注意什么？

	如果大量的key同时过期，则用户的操作一般都会直接
	打在MySQL上，会增加数据库的压力。

	1. 可以通过给过期时间加上一定的随机性，减少同时过期的概率

	2. 对服务进行降级

	当业务应用访问的是非核心数据（例如电商商品属性）时，
	暂时停止从缓存中查询这些数据，而是直接返回预定义信息、空值或是错误信息；

	当业务应用访问的是核心数据（例如电商商品库存）时，仍然允许查询缓存，
	如果缓存缺失，也可以继续通过数据库读取。

- 使用过redis做异步队列，你是怎么用的？

	1. 使用了链表进行操作。
	2. 也可以使用发布订阅，但是消费者下线的时候会出现消息丢失的问题。

- 跳表 - Zet结构

	TODO

- Redis分布式锁

	先拿 setnx 来争抢锁，抢到之后，再用 expire 给锁加一个过期时间防止锁忘记了释放。
	set 指令有非常复杂的参数，这个应该是可以同时把 setnx 和 expire 合成一条指令来用

- redisson

	TODO

- Redis集群批量获取key有什么问题
- 有哪些redis集群
- Redis缓存击穿 雪崩
- 分布式id 雪花算法原理
- Redis cluster和主从有什么区别
- 一台redis挂了拿不到key了怎么办
- Redis用在哪些场景
- 数据过期的拉新操作
- Redis主从同步过程
- 跳表能换成红黑树吗
- Rdb aof、aof太大怎么办
- Redis hash扩容
- redis为什么快

	都是内存操作
	IO多路复用
	高效的数据结构

- redis是怎么做的高可用
- redis选举详细过程
- Redis的IO模型
- 用redis实现分布式锁有什么潜在的问题
  - https://zhuanlan.zhihu.com/p/112651338
- redis怎么实现事务 
- redis6.0是怎么实现多线程的
- 单链表找到中间节点
- redis写入通信协议是什么？ 
- redis写入操作IO操作快是因为异步
- redis的setnx底层怎么实现的？
- 使用预加载到redis的形式去计算发放数量，怎么跟数据库保持一致性？
- 用户端的活动数据怎么保证高并发访问不挂？
- 一致性hash，虚拟节点作用，为什么一致性hash是一个环。 
