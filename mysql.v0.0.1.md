## 基础知识
- sql语句的执行过程

	1. 会经历5个过程
	2. 连接器

		负责管理用户的登录操作，会对用户进行一定的身份认证
		校验用户的账号密码、权限。
		（如果连接不断开，即使管理员更改了权限，用户的权限也是不受影响的）

	3. 缓存查询
		
		在执行查询语句的时候，首先会进行这一步。如果对应的SQL被校验
		存储在缓存当中，就会直接返回给客户端。
		在缓存中，SQL和结果集是以Key-Value的形式存在的，是对大小写等都敏感的
		如果SQL即使有一丁点不同，都不会命中。（使用哈希函数计算？）

	4. 分析器(预处理器)

		分析器会对SQL进行两个操作，生成解析树:

		a. 词法分析：提取关键字
		b. 语法分析：判断SQL是否正确，符合语法。

	5. 优化器

		优化器的作用就是它认为的最优的执行方案去执行.
		根据解析树，生成不同的执行计划，然后选择认为是最优的执行计划。
		（show status like 'last_query_cost'; 可以查看开销）

	6. 执行器

		根据优化器产出的执行计划，调用底层引擎的接口，并返回结果。

- 数据库补偿？步长？原理

	TODO

- Mysql有哪些引擎有哪些区别

	1. InnoDB

		支持事务
		行级锁
		聚簇索引
		支持崩溃后的数据安全恢复

	2. MyISAM

		不支持事务和行级锁，而且在崩溃后无法安全恢复
		MyISAM是对整个表加锁，而不是行锁
		MyISAM另一个特性是支持压缩表。如果数据在写入后不会修改，那么这个表适合MyISAM压缩表。
		MyISAM可以选择延迟更新索引键
		索引构建方式和InnoDB不一样

	3. Archive

		但是在每次Select查询都需要执行全表扫描
		所以在Archive适合日志和数据采集应用。
		这类应用在分析时往往需要全表扫描忙活着更快的Insert操作场景中也可以使用.

	4. CSV

		CSV引擎可以将普通的CSV文件作为MySQL表来处理，
		但是这种表不支持索引，CSV可以在数据库运行时拷贝或者拷出文件

	5. Memory

		所有的数据都保存在内存中，不需要进行磁盘I/O。
		Memory表的结构在重启以后还会保留，但数据会丢失。

	6. NDB

		NDB集群存储引擎，作为SQL和NDB原生协议之间的接口

	7. Merge

		Merge引擎是MyISAM引擎的一个变种。

	8. 其他

- 什么是覆盖索引

	1. 覆盖索引是select的数据列只用从索引中就能够取得，
		不必读取数据行，换句话说查询列要被所建的索引覆盖。
		(即查询数据的时候不用进行回表操作)

	2. 如果使用了覆盖索引，使用Explain分析则 Extra字段会输出Using index

	** https://juejin.cn/post/6844903967365791752 **
	
- Mysql有哪些日志

	1. binlog 
		
		a. binlog是mysql用来记录数据库表结构变更以及表数据修改的的二进制日志，
			它只会记录表的变更操作，但不会记录select和show这种查询操作。

		b. 主要用作：数据恢复、主从复制、审计

		c. 有三种记录模式
			
			ROW：记录的是每一行被修改的数据, 会产生大量的日志，
				尤其是alter table会让日志文件大小暴涨
			STATEMENT：记录的是执行的SQL语句, 日志量小，减少磁盘IO，
				提升存储和恢复速度,在某些情况下会导致主从数据不一致
			MIXED：statement和row模式的混合, 准确性强，文件大小适中
				普通复制不会有问题，但是级联复制在特殊情况下会binlog丢失
		
		d. 刷盘策略

			有一个sync_binlog参数可以控制binlog的刷盘策略，他的默认值是0，
			此时你把binlog写入磁盘的时候，其实不是直接进入磁盘文件，
			而是进入os cache内存缓存。

			如果要是把sync_binlog参数设置为1的话，那么此时会强制在提交事务的时候，
			把binlog直接写入到磁盘文件里去，那么这样提交事务之后，
			哪怕机器宕机，磁盘上的binlog是不会丢失的

			每N个事务，才会将binlog写入磁盘。

	2. redo log
		
		redo log包括两部分：一个是内存中的日志缓冲(redo log buffer)，
		另一个是磁盘上的日志文件(redo log file)
		
		mysql每执行一条DML语句，先将记录写入redo log buffer，
		后续某个时间点再一次性将多个操作记录写到redo log file

		采用一个类似ring buffer的环形数据结构进行记录

		redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用
		
		redo log是物理日志，记录的是“在某个数据页上做了什么修改”；
		binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”。

		redo log是循环写的，空间固定会用完；binlog是可以追加写入的。
		“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志
	
	3. undo log

		MySQL 中 undolog 是 MVCC 技术实现的重要组成部分，一致性读功能也需要用到 undolog。
		当然，更重要的一点就是用于回滚。如事务执行失败后，通过 undolog 进行回滚恢复到之前的状态。

		undolog 是一个链表结构。

		每次对数据进行 INSERT、UPDATE（DELETE） 时，都会将旧数据存储到 undolog 中。
		然后在数据行中修改字段DB_ROLL_PTR 指向对应的 undolog，以便在需要时查询到之前的数据。

		回滚时通过字段DB_ROLL_PTR找到 undolog 中记录的旧数据回滚即可。

		InnoDB 存储引擎对 undolog 的管理采用段的方式。undolog records 
		存储于 undolog segment 中，undolog segment 又存储在 rollback segment 中，
		rollback segment 则存放在 undo tablespace 中.
		另外，undo log也会产生 redo log，因为 undo log 也需要实现持久性保护。

		同时还有很重要的一点就是，一个 undolog segment 只能同时被一个事务使用。
		也就是说 InnoDB 存储引擎的并发事务数还会受到 undolog segment 数量限制。

	4. 慢查询日志
	5. 错误日志
	6. 普通日志

- Mysql事务隔离级别

	1. 未提交读

		所有事务都可以看到其他未提交事务的执行结果
		无法解决脏读、不可重复读、幻读

	2. 提交读
		
		无法解决不可重复读、幻读问题
		可以看到其他事务提交的内容

	3. 可重复读

		会出现幻读的问题
		InnoDB使用MVCC和间隙锁解决了这个问题

	4. 串行化	
	
		数据最安全的级别，但是所有的语句都是串行执行的
		性能比较低

- 事务的特性
	
	1. 原子性（Atomicity）
	2. 一致性（Consistency）
	3. 隔离性（Isolation）
	4. 持久性（Durability）

- Mysql有哪些锁

	1. 共享锁与排他锁

		共享锁（读锁）：其他事务可以读，但不能写。
		排他锁（写锁） ：其他事务不能读取，也不能写。

	2. MyISAM 和 MEMORY 存储引擎采用的是表级锁（table-level locking）
		BDB 存储引擎采用的是页面锁（page-level locking），但也支持表级锁
		InnoDB 存储引擎既支持行级锁（row-level locking），
		也支持表级锁，但默认情况下是采用行级锁。

	3. 表共享读锁 表独占写锁 

	4. InnoDB
		
		意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。
		意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。
		
		共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
		排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。

		间隙锁：当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，
		InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，
		叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，
		这种锁机制就是所谓的间隙锁（Next-Key锁）

		不论是使用主键索引、唯一索引或普通索引，InnoDB 都会使用行锁来对数据加锁。

- 乐观锁的实现方式

	乐观锁, 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，
	但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。
	乐观锁适用于多读的应用类型，这样可以提高吞吐量，
	像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。

- 索引是什么数据结构 为什么要用b+树

	B+树。

	1. B+ 树中的数据可以分成页，更适合做区间访问。
	2. 相比其他的数据结构，可以减少随机IO，更好地适应局部性原理。

- B树 与 B+ 树比较

	1. B+树内节点不存储数据，所有 data 存储在叶节点导致查询时间复杂度固定 
		而B-树查询时间复杂度不固定，与 key 在树中的位置有关，最好为O(1)。

	2. B+树叶节点两两相连可大大增加区间访问性，可使用在范围查询等，
		而B-树每个节点 key 和 data 在一起，则无法区间查找。
	
	3. B+树更适合外部存储。由于内节点无 data 域，每个节点能索引的范围更大更精确

- 最左匹配原则

	如创建一个（a,b）的联合索引，用索引中的a筛选数据，
	可以走索引，如果只用b进行数据筛选，则走不到索引

	还有模糊查询的时候，如果使用a字段进行左模糊查询，就用不到查询
	右模糊查询就可以。

- 慢查询怎么排查？

	1. 如果有开慢查询日志，就可以去看慢查询日志，
		看看是目前存在哪些慢查询日志，并且是
		线上使用账号进行的

	2. 找到SQL之后，使用Explain，对SQL进行分析
		看看为什么没有走到索引，索引设计得有没有问题
		是不是查询多了数据，是不是出选了File sort问题，
		是不是出现了死锁问题

- Mysql 索引数据结构 聚集非聚集

	1. B+树 
	2. 聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据
	3. 非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行o
	4. MyISAM 是使用非聚簇索引，InnoDB的主键使用聚簇索引（会有隐式非空主键）
	5. 聚簇索引优势

		由于行数据和叶子节点存储在一起，同一页中会有多条行数据，
		访问同一数据页不同行记录时，已经把页加载到了Buffer中，
		再次访问的时候，会在内存中完成访问，不必访问磁盘。
		
		辅助索引使用主键作为"指针"而不是使用地址值作为指针的好处是，
		减少了当出现行移动或者数据页分裂时辅助索引的维护工作，
		使用主键值当作指针会让辅助索引占用更多的空间，
		换来的好处是InnoDB在移动行时无须更新辅助索引中的这个"指针"。

		聚簇索引适合用在排序的场合，非聚簇索引不适合
		
		取出一定范围数据的时候，使用用聚簇索引
		
		二级索引需要两次索引查找，而不是一次才能取到数据

	4. 聚簇索引劣势
			
		维护索引很昂贵，特别是插入新行或者主键被更新导至要分页(page split)的时候
		还会造成碎片

- 锁是锁聚集索引还是非聚集索引

	(猜测是都锁)

- 死锁 答了死锁条件、死锁避免 银行家算法

	是指两个或两个以上的进程在执行过程中, 
	因争夺资源而造成的一种互相等待锁释放的现象, 
	若无外力作用，它们都将无法推进下去.
	此时称系统处于死锁状态或系统产生了死锁

	1. InnoDB做了比较多的事情防止死锁，主要是为表、数据行加上意向锁、共享锁
		来实现

	2. 并且在死锁的时候，会使用 wait-for graph算法 来进行检测
		并选择认为是最小影响的事务进行回滚
		(主要是查看图是否出现了环路)

- 为什么2000万数据是三层
- 为什么一页是16k

	1. linux 中的数据页是8K, 有一些系统是 4K，所以一般都要是系统的页的倍数才行

- 串行化相对于可重复读级别主要解决了什么问题

	1. 幻读的问题，即在一个事务中进行查询，另一个事务插入了几行，
		导致第一个事务后续查询中发现多了几行，就称为幻读

- mysql 里，varchar 和 char的区别？

	1. 最大长度：char是255，varchar是65535，单位是字符
	2. 尾随空格：char会将尾随空格去掉，而varchar不会。
	3. 存储空间占用：varchar会占用额外的1~2字节来存储字符串长度。
		如果最大长度超过255，就需要2字节，否则1字节。

- 如果我给你7个字节的字符串，插入char(6)和varchar(6)会发生什么？

	如果第七个是空字符串char会截断，否则报错

	varchar会报错

- 主从库怎么做，原理是什么

	1. MySQL主从是基于binlog的，主上须开启binlog才能进行主从。

	2. 	原理
		
		将更改操作记录到binlog里
		将主的binlog事件(sql语句)同步到从本机上并记录在relaylog里中继日志
		从根据relaylog里面的sql语句按顺序执行

- 怎么避免幻读/脏读

	1. MVCC 和 锁（间隙锁，Next-key Locking）

- 一个update语句的执行过程

	** https://blog.csdn.net/baiye_xing/article/details/113032790 **

- MVCC原理

	TODO

- ACID的涵义，MYSQL是如何保证的

	TODO	

- 分库之后唯一性如何保证

	TODO

- 数据库加密算法是怎么设计的？设计这种东西通用规范是怎么设计的？ 

	TODO

- 据库三大范式是什么

	1. 第一范式：每个列都不可以再拆分。
		如电话：可以分为联系电话、家庭电话
		姓名：分为姓、名
	2. 第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依
	赖于主键的一部分。
	3. 第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他
	非主键。

	在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够
	的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。

- MySQL 有关权限的表都有哪几个
- MySQL 的 Binlog 有有几种录入格式？分别有什么区别？
- MyISAM 索引与 InnoDB 索引的区别
- MySQL 存储引擎 MyISAM 与 InnoDB 区别 
- 什么是索引？
- 索引有哪些优缺点？
- 索引有哪几种类型？
- MySQL 中有哪几种锁？
- MySQL 中 InnoDB 支持的四种事务隔离级别名称，以及逐级之间的区别？
- char 和 varchar 的区别？
- 主键和候选键有什么区别？
- 如何在 Unix 和 MySQL 时间戳之间进行转换？
- MyISAM 表类型将在哪里存储，并且还提供其存储格式？
- MySQL 里记录货币用什么字段类型好
- 创建索引时需要注意什么？

	1. 非空字段：应该指定列为 NOT NULL，除非你想存储 NULL。在 mysql 中，含
		有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及
		比较运算更加复杂。应该用 0、一个特殊的值或者一个空串代替空值；
	2. 取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引
		的前面，可以通过 count()函数查看字段的差异值，返回值越大说明字段的
		唯一值越多字段的离散程度高；
	3. 索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一
		次 IO 操作获取的数据越大效率越高。

- 使用索引查询一定能提高查询的性能吗？为什么
- 百万级别或以上的数据如何删除
- 什么是最左前缀原则？什么是最左匹配原则
- 什么是聚簇索引？何时使用聚簇索引与非聚簇索引
- MySQL 连接器
- MySQL 查询缓存
- MySQL 分析器
- MySQL 优化器
- MySQL 执行器
- 什么是临时表，何时删除临时表？

	MySQL 在执行 SQL 语句的过程中 通常会临时创建一些存储中间
	结果集的表，临时表只对当前连接可见，在连接关闭时，临时表会被删除并
	释放所有表空间。
	
	临时表分为两种:一种是内存临时表，一种是磁盘临时表，什么区别呢?内存临
		时表使用的是 MEMORY 存储引擎，而临时表采用的是 MylSAM 存储引擎

	MySQL 会在下面这几种情况产生临时表。

	1. 使用 UNION 查询:UNION 有两种，一种是 UNION，一种是 UNION ALL，它们
		都用于联合查询;区别是使用 UNION 会去掉两个表中的重复数据，相当于对
		结果集做了一下 去重(distinct)。使用 UNIONALL，则不会排重，返回所有
		的行。使用 UNION 查询会产生临时表。

	2. 使用 TEMPTABLE 算法或者是 UNION 查询中的视图。TEMPTABLE 算法是一种创
		建临时表的算法，它是将结果放置到临时表中，意味这要 MySQL 要先创建
		好一个临时表，然后将结果放到临时表中去，然后再使用这个临时表进行
		相应的查询。

	3. ORDER BY 和 GROUPBY 的子句不一样时也会产生临时表。

	4. DISTINCT 查询并且加上 ORDER BY 时;

	5. SQL 中用到 SQL_SMALL_RESULT 选项时;如果查询结果比较小的时候，可以加
		
		SQL SMALL RESULT 来优化，产生临时表

	6. FROM 中的子查询;

	7. EXPLAIN 查看执行计划结果的 Extra 列中，如果使用 Using Temporary 就
		表示会用到临时表。


- 谈谈 SQL 优化的经验

	1. 查询语句无论是使用哪种判断条件等于、小于、大于，WHERE 左侧的条件
		查询字段不要使用函数或者表达式
	2. 使用 EXPLAIN 命令优化你的 SELECT 查询，对于复杂、效率低的 sql 语
		句，我们通常是使用 explain sql 来分析这条 sql 语句，这样方便我们分
		析，进行优化。
	3. 当你的 SELECT 查询语句只需要使用一条记录时，要使用 LIMIT 1。不要
		直接使用 SELECT*，而应该使用具体需要查询的表字段，因为使用 EXPLAIN
		进行分析时，SELECT"使用的是全表扫描，也就是 type =all 。
	4. 为每一张表设置一个 ID 属性。
	5. 避免在 MHERE 字句中对字段进行 NULL 
	6. 判断避免在 WHERE 中使用!或>操作符
	7. 使用 BETWEEN AND 替代 IN
	8. 为搜索字段创建索引
	9. 选择正确的存储引擎，InnoDB、MyISAM、MEMORY 等
	10. 使用 LIKE%abc%不会走索引，而使用 LIKE abc%会走索引。
	11. 对于枚举类型的字段(即有固定罗列值的字段)，建议使用 ENUM 而不是
		VARCHAR，如性别、星期、类型、类别等。
	12. 拆分大的 DELETE 或 INSERT 语句
	13. 选择合适的字段类型，选择标准是尽可能小、尽可能定长、尽可能使用整数。
	14. 字段设计尽可能使用 NOT NULL
	15. 进行水平切割或者垂直分割

- 什么叫外链接？
- 什么叫内链接？
- 使用 union 和 union all 时需要注意些什么？
- MyISAM 存储引擎的特点
- InnoDB 存储引擎的特点
- 覆盖查询&回表查询
- 分库分表联表查询有哪些方式
- 什么操作会影响联表查询效率
- 什么情况下不使用索引比较好
- Select count（1） count（*） count（clonum）区别

	在统计范围，count(*)和count(1) 一样，都包括对NULL的统计；
	count(column) 是不包括NULL的统计。
	
	表沒有主键(Primary key)，count(1)比count(*)快；
	否则，主键作为count的参数时，count(主键)比count(1)和count(*)都快；
	表只有一个字段，count(*)，count(1)和count(主键)速度一样。

- 什么时候建立索引
- 城市字段适合建索引吗
- 数据库 in用的了索引吗
- mysql的分表是怎么处理的
- 数据库所有类型字段都能建索引吗
- File sort的原因，怎么优化
- SQL语言包括哪几部分？每部分都有哪些操作关键字？
- 完整性约束包括哪些？
- 什么叫视图？游标是什么？
- NULL是什么意思
- 什么是索引下推
- 假设现在有人操作数据库，不小心执行错了语句，误删除了很多数据，这时候能恢复吗？
- 你知道主从延迟吗？有些时候延迟的时间还会很长。遇到这种情况咋么办？

## SQL优化
- 订单分表场景怎么按用户关联多个分表查
- 数据库嵌套表 取 省 市 县
- 一亿数据的a表 十亿数据的b表，按都有的tid 关联数据查出第10001到10200的数据
- 联合索引abc问题
- 两张大表级联查询的优化
- 数据库 abc ab% %bc “” null 哪些可以用索引
- 分析mysql慢的原因 explain有哪些字段可以判断
- 两张表用户表user和帖子表thread，查找发帖数量前10的用户名和发帖数量
- 联合索引abc 为什么bc不行
- mysql取模分表热点数据怎么解决
- 如果情况极端一点，单表500W的数据量，写一条sql连表查前10条用户信息。
- 如果数据量再大一点，达到千万级别。估计加一条索引需要20分钟，你要怎么处理让他快速加上去？
- 写sql，深翻页优化
- NULL是什么意思
