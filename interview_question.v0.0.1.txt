1. Slice和数组

    1.1. Go语言数组和切片有什么区别 

        a. 首先得先知道数组的底层原理：

            1. 本质上是相同类型元素的集合组成的数据结构，
                计算机会为数组分配一块连续的内存来保存其中的元素

            2. 与很多语言不同，Go 语言中数组在初始化之后大小就无法改变。

            3. 存储元素类型相同、但是大小不同的数组类型在 Go
                语言看来也是完全不同的，只有两个条件都相同才是同一个类型

            4. 获取数组大小、对数组中的元素的读写在编译期间就已经进行了简化

            （
                NOTE: 如果数组中元素的个数小于或者等于 4 个，
                    那么所有的变量会直接在栈上初始化，
                    如果数组元素大于 4个，变量就会在静态存储区初始化然后拷贝到栈上
                    (?这样做的原因是什么暂时不是很清楚?)
                    这个处理是在编译期间做的，这些转换后的代码才会
                    继续进入中间代码生成和机器码生成两个阶段，
                    最后生成可以执行的二进制文件。

                NOTE: 
                    1. Go 语言中对越界的判断是可以在编译期间由静态类型检查完成
                        数组和字符串的一些简单越界错误都会在编译期间发现，
                        比如我们直接使用整数或者常量访问数组

                    2. 但是如果使用变量去访问数组或者字符串时，
                        编译器就无法发现对应的错误了，
                        这时就需要 Go 语言运行时发挥作用了
            ）

        b. 切片其实底层原理是围绕着数组进行的, 他的底层数据结构包括三部分。data len cap.
            
            1. 首先data作为一个指针指向的数组是一片连续的内存空间.
                在同一个底层数组被多个slice使用的时候，编程的时候就需要注意，
                这个地方可能会有坑。

            2. 现切片与数组的关系非常密切，切片引入了一个抽象层，
                使用 len cap 两个属性提供了对数组中部分片段的引用

            3. 如果底层的数组长度不足就会触发扩容机制，切片中的数组就会发

            4. 不过在上层看来切片时是没有变化的，因为上层只需要与切片
                打交道不需要关心底层的数组变化。

            5. 切片是运行时才会确定内容的结构，所有的操作还需要依赖 Go 语言的运行时来完成
        
        c. 就上面所以他们的不同常常体现在以下几点
            
            1. 本质上的数据结构不一样，切片依赖数组，会保存一个底层数组的指针。
            
            2. Go 语言中数组在初始化之后大小就无法改变，但是切片可以，他一套扩容机制

            3. 切片有自身的扩容机制

            4. 获取数组大小、对数组中的元素的读写在编译期间就已经进行了简化. 而切片的大部分操作
                都需要在go运行时进行确定。

            5. 并且因为底层数据结构不太一样的情况之下，他们所保存的数据的读取方式也不一样。

        d. （还要描述一下切片的初始换、数组的初始化、数组的数据读取、切片中数据读取吗？）

    1.2. Go语言切片的内存结构和扩容 

        a. 切片的数据结构如下
            1. data -> 一个执行数组的指针， 本质上是一片连续的内存
            2. len -> 当前切片的长度
            3. cap -> 示当前切片的容量
        
        b. 关于扩容，我们就要分成三部分进行讲解
            
            1. 首先是什么条件之下才会触发扩容

                1.1. 使用 append 关键字向切片追加元素。
                    新的slice长度大于容量就会扩容。
                    此项工作会有编译器会进行一定的处理。

                    （
                        编译器判断是否会覆盖原变量来
                        拆分 append 关键字，新建两个处理流程。
                        两种流程区别不大。

                        ---『新切片』不需要赋值回原有的变量 ---
                        * append(slice, 1, 2, 3)

                        先对切片结构体进行解构获取它的数组指针、大小和容量
                        如果在追加元素后切片的大小大于容量
                        调用 runtime.growslice 对切片进行扩容并将新的元素依次加入切片

                        --- 如果 append 后的切片会覆盖原切片 ----
                        * slice = append(slice, 1, 2, 3)

                        此时会使用另一种方式改写关键字
                    ）

            2. 然后是扩容的具体操作

                2.1. 扩容就是为切片分配一块新的内存空间并将原切片的元素全部拷贝过去

                2.2. 在分配内存空间之前需要先确定新的切片容量

                2.3. Go 语言根据切片的当前容量选择不同的策略进行扩容

                    2.3.1. 如果期望容量大于当前容量的两倍就会使用期望容量；
                    2.3.2. 如果当前切片容量小于 1024 就会将容量翻倍；
                    2.3.3. 如果当前切片容量大于 1024 就会每次增加 25% 的容量，
                        直到新容量大于期望容量；
                
                2.4. 确定了切片的容量之后，就可以计算切片中新数组占用的内存

                    (
                        计算的方法就是将目标容量和元素大小相乘
                        计算新容量时可能会发生溢出或者请求的内存超过上限，在这时就会直接 panic
                    )

                2.5. 最终会返回一个新的 slice 结构，其中包含了新的数组指针、大小和容量.
                    会改变原有的切片.

            3. 就是扩容导致的后果，有哪些是需要我们注意的？
                
                3.1. 由于扩容之后原切片的会被改变，底层的数组会被改变，
                    这个是我们编程的时候比较需要进行注意的点。

                    （
                        1. 多个slice共享一个底层数组的代码逻辑，他们之间是否有依赖？
                        2. 作为参数的时候，如果append之后，再去更改里面的值，不将新指针
                            返回，就不能达到预期。
                    ）

    1.3. slice 在for一遍之后会改变内容吗

        （题意不明，如果是使用for range，如果用index去改变之，就是会改变的）

    1.4. 数组是如何实现用下标访问任意元素的

        1.4.1 数组是一片连续的内存，如果我们知道下标可以即可快速地算出每一个元素的内存地址

                addr = sizeof(Type) * idx + addr_head
        
        1.4.2 当我们知道虚拟内存的地址的时候，系统就可以通过 MMU 直接翻译成物理地址，读取到
            物理内存中的内容

    1.5. 如何复制切片

        a. 如果需要的是深拷贝

            1. 使用copy()函数进行拷贝，但是需要注意的是

                [目标切片必须分配过空间且足够承载复制的元素个数]

                [当我们使用copy(a, b) 的形式对切片进行拷贝时,
                    编译期间会分两种情况进行处理]

                [相比于依次对元素进行拷贝，这种方式能够提供更好的性能, 
                    最终都会使用memmove复制内存快]

                [哪怕使用 memmove 对内存成块进行拷贝，
                    但是这个操作还是会占用非常多的资源，
                    在大切片上执行拷贝操作时一定要注意性能影响]

            2. 使用for range，遍历切片元素，  append进新数组。

            3. 或直接append整个数组进去 

                new := append(new, old...)

        b. 如果需要的是浅拷贝，直接赋值就可以，但是
            需要注意由于slice的底层原理，新旧slice都用的
            同一个数组的指针，会出现因共享内存而引入的风险。

                new := old

2. Channel

    1. 介绍一下通道
    2. 同一个协程里面，对无缓冲channel同时发送和接收数据有什么问题 
    3. channel和锁对比一下
    4. channel的应用场景
    5. channel和共享内存有什么优劣势？
    6. gochannel实现排序 
    7. Go 语言当中 Channel（通道）有什么特点，需要注意什么？ 
    8. Go 语言当中 Channel 缓冲有什么特点？ 
    9. Go 语言中 cap 函数可以作用于那些内容？
    10. Go 语言的 Channel 特性？ 
    11. Channel 的 ring buffer 实现 

    12. for循环select时，如果通道已经关闭会怎么样？如果select中的case只有一个，又会怎么样？
        
        a. 尝试读取一个已经关闭的通道，如果是缓冲的Channel，就会优先
            返回缓冲区里面的数据，直到缓冲区没有数据后一直返回零值。
            如果是没缓冲区的channel，就会一直返回零值。
            
        b. 如果只有一个case，就会一直执行这个case里面的代码逻辑。

        c. 如果有多个case，那就视具体情况，随机执行。
        
    13. 读或写一个已经关闭的channel会发生什么问题？

3. 锁

    1. go用共享内存的方式实现并发如何保证安全？
    2. go的锁是可重入的吗？ 
    3. 获取不到锁会一直等待吗？ 
    4. 那如何实现一个timeout的锁？
    5. Go 当中同步锁有什么特点？作用是什么 
    6. Mutex 几种状态 
    7. Mutex 正常模式和饥饿模式 
    8. Mutex 允许自旋的条件 
    9. RWMutex 实现 
    10. RWMutex 注意事项 
    11. Cond 是什么 
    12. Broadcast 和 Signal 区别 
    13. Cond 中 Wait 使用 
    14. WaitGroup 用法 
    15. WaitGroup 实现原理 
    16. 什么是 sync.Once 
    17. 什么操作叫做原子操作 
    18. 原子操作和锁的区别 
    19. 什么是 CAS 

4. INTERFACE

    4.1. go里面interface是什么概念 
    4.2. Go 两个接口之间可以存在什么关系？ 

5. String 和 Byte

    5.1. string和byte数组有什么区别？

6. struct

    6.1. struct之间能比较吗，什么情况下能比较？
        
        分为两种情况 （cnblogs.com/dashu-saycode/p/14286228.html）

        a. 同一个struct的不同示例比较

            1. 结构体里面的元素类型只有
                Integer，Floating-point，String，Boolean，
                Complex(复数型)，Pointer，Channel，Interface，Array
                的可以比较。否则不可比较

            2. 如果机构体里的元素类型有
                Slice，Map，Function
                则不可比较，在尝试编译的时候，就会报错

        b. 不同struct的实例进行比较
            
            1. 如果两个struct都只包含可比较的元素类型的时候，
                并且struct中的元素数据类型一致，通过强制转换可以比较
                （顺序不一样不可以比较，不能强制转换，无法通过编译）

            2. 否则不可比较
        
        c. 可以使用reflect.DeepEqual函数进行比较

            （
                具体对比规则需要进行补充操作
            ）

    6.2. go结构体和结构体指针的区别 

    6.3. 空struct应用场景

        a. golang 正常的 struct 就是普通的一个内存块，必定是占用一小块内存的. 
            并且结构体的大小是要经过边界，长度的对齐的，
            但是“空结构体”是不占内存的，size 为 0.

        b. 本质上来讲，使用空结构体的初衷只有一个：节省内存，但是更多的情况，
            节省的内存其实很有限，这种情况使用空结构体的考量其实是：
            根本不关心结构体变量的值。
        
        c. 主要分为三块

            1. 实现方法接收者

                有时候我们需要将一些 <方法> 分类起来，便于后续拓展和维护。
                如果我们使用：

                    比如有时候我们需要实现一个可以进行加法计算的函数，
                    和一个减法计算的函数。此时我们认为他是有类似的，需要
                    进行计算操作的函数。并可能后续会扩展其他的，如
                    指数运算的功能，并将这些方法扩展成一个计算器(calculator)。
                    这时，我们需要一个 <数据类型> 来管理他，但是不希望增加
                    计算机的负载。在这种情况下，如果我们用int、string等type
                    会消耗一定的内存，产生很多小内存对象，但是使用空struct
                    就不会出现这种情况，因为空struct不会消耗内存。

                    --- 分组1
                    type calculateInt struct{} 

                    func (c calculateInt) add(x,y int) int {
                        return x+y
                    }

                    func (c calculateInt) sub(x,y int) int {
                        return x-y
                    }
                    --- 分组1

                    --- 分组2
                    type calculateInt2 struct{} 

                    func (c calculateInt2) add(x,y int) int {
                        return x+y
                    }

                    func (c calculateInt2) sub(x,y int) int {
                        return x-y
                    }
                    --- 分组2
                

            2. 实现集合类型

                    a. 在 Go 语言的标准库中并没有提供集合（Set）的相关实现，
                        因此一般在代码中我们图方便 (仅仅是图方便，不一定性能好，
                        因为map底层机制，会扩容，用空间换时间) ，
                        会直接用 map 来替代。

                    b. 但有个问题，就是集合类型的使用，
                        只需要用到 key（键），不需要 value（值）。
                    
                    c. 空结构体作为占位符，不会额外增加不必要的内存开销，
                        很方便的就是解决了。

                    --- 例1 ---
                    type Set map[string]struct{}

                    func (s Set) Append(k string) {
                        s[k] = struct{}{}
                    }

                    func (s Set) Remove(k string) {
                        delete(s, k)
                    }

                    func (s Set) Exist(k string) bool {
                        _, ok := s[k]
                        return ok
                    }

                    func main() {
                        set := Set{}
                        set.Append("煎鱼")
                        set.Append("咸鱼")
                        set.Append("蒸鱼")
                        set.Remove("煎鱼")

                        fmt.Println(set.Exist("煎鱼"))
                    }
                    --- 例1 ---

            3. 实现空通道

                a. 在 Go channel 的使用场景中，常常会遇到通知型 channel，
                    其不需要发送任何数据，只是用于协调 Goroutine 的运行，
                    用于流转各类状态或是控制并发情况。

7. MAP

    7.1. hash冲突解决办法，有什么弊端
    7.2. map里面解决hash冲突怎么做的，冲突了元素放在头还是尾
    7.3. map取一个key，然后修改这个值，原map数据的值会不会变化 
    7.4. map如何顺序读取
    7.5. Golang Map 底层实现 
    7.6. Golang Map 如何扩容 
    7.7. Golang Map 查找 
    7.8. 如何复制map

        a. 其实是不能拷贝的，如果想要拷贝一个 map ，只有一种办法就是循环赋值

        b. 如果map中元素保存了指针，则需进一步考虑指针元素的深拷贝问题

            (   
                问了再答？：
                map作为一个封装好的数据结构，由于它底层可能会由于数据扩张而进行迁移，
                所以拒绝直接寻址，避免产生野指针。
                map中的key在不存在的时候，赋值语句其实会进行新的k-v值的插入，
                所以拒绝直接寻址结构体内的字段，以防结构体不存在的时候可能造成的错误
            )
        
        c. 最简单的方法是用json unmarshal，变成字符串，
            然后再用 json marshal生成新的map。
            这种方法对结构体也适用，但是性能较差。

8. Runtime

    1. 调度
        1.1. 协程怎么切换的
        1.2. 多线程用过吗 写了三个线程实现同步的代码
        1.3. 线程池实现原理
        1.4. Go的GMP模型
        1.5. Go创建协程的过程知道吗
        1.6. go调度中阻塞都有那些方式
        1.7. GPM模型里如果本地队列满了，新增的g会怎么处理
        1.8. goroutine创建数量有限制吗？
        1.9. 开多少个p由什么决定 
        1.10. m和p是什么样的关系 
        1.11. 同时启了一万个g，如何调度的？
        1.12. 为什么不要大量使用goroutine 
        1.13. 如何拿到多个goroutine的返回值，如何区别他们 
        1.14. GMP 中 hand off 机制 
        1.15. 协作式的抢占式调度 
        1.16. 基于信号的抢占式调度 
        1.17. GMP 调度过程中存在哪些阻塞 
        1.18. sysmon 有什么作用 

    2. GC

        2.1. 介绍一下Go的GC
        2.2. 聊聊gc，三色是什么？gc的过程呢？什么时候触发gc呢？
        2.3. 如果a=5, b=a , c = &a ,gc启动后，a,b,c是什么颜色的？为什么？
        2.4. go的GC和PHP和python的GC
        2.5. go语言什么时候垃圾回收，写代码的时候如何减少小对象分配
        2.6. 什么情况会内存逃逸？
        2.7. 三色标记原理 
        2.8. GC 触发时机 
        2.9. 混合写屏障 
        2.10. 插入写屏障 
        2.11. 删除写屏障 
        2.12. Go 语言中 GC 的流程是什么？ 
        2.13. GC 如何调优 

    3. 内存管理
        3.1 Go语言内存分配，什么分配在堆上，什么分配在栈上。
        3.2 go的值传递和引用传递

9. 出名的Package

    9.1. 介绍一下Go的context
    9.2. sync.map与map的区别，怎么实现的
    9.3. runtime包里面的方法
    9.4. syncpool的实现原理
    9.5. gowaitgroup的坑
    9.6. go convey 是什么？一般用来做什么？ 
    9.7. Printf(),Sprintf(),FprintF() 都是格式化输出，有什么不同？ 

10. 其他

    10.1. go的init函数是什么时候执行的？
    10.2. 多个init函数执行顺序能保证吗？
    10.3. go 怎么实现func的自定义参数
    10.4. go实现不重启热部署
    10.5. go性能分析工具
    10.6. go深拷贝，什么时候需要深拷贝
    10.7. go如何避免panic
    10.8. 读过什么go源码没有
    10.9. defer用的多吗？有哪些应用
    10.10. go里面比较成熟的日志框架了解过没有
    10.11. for range坑
    10.12. 遇到过什么语法问题
    10.13. go实现一个并发限制爬虫
    10.14. go怎么实现封装继承多态
    10.15. PHP 和 Go 对比 
    10.16. Go的闭包语法
    10.17. defer recover 的问题（自己了解不多，简单介绍）
    10.18. 项目调试（讲了下GDB） 
    10.19. 与其他语言相比，使用 Go 有什么好处 
    10.20. Golang 使用什么数据类型 
    10.21. Go 程序中的包是什么 
    10.22. Go 支持什么形式的类型转换？将整数转换为浮点数 
    10.23. 什么是 Goroutine？你如何停止它？ 
    10.24. 如何在运行时检查变量类型 
    10.25. Go 语言当中 new 和 make 有什么区别吗？ 
    10.26. Go 语言中 make 的作用是什么？ 
    10.27. Golang 的参数传递、引用类型 

    10.28. 协程(goroutine)间通信方式

        a. 第一种就是Go最推荐的方式，使用Channel，分为两种情况
            1. 无缓冲Channel

                make(chan struct{})

            2. 有缓冲Channel

                make(chan struct{}, 3)

            3. 需要注意的就是无缓冲的 channel 是同步的，
                而有缓冲的 channel 是非同步的。

        b. 经典的共享内存方式，例如通过加锁（如互斥锁）来实现共享内存。

11. GIN
    
    1. gin框架的路由是怎么处理的
    2. gin如何做ssl

12. 单元测试
    
    1. 如果一个包要依赖另一个包，这个时候如何写单元测试
